

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>matrxs.agents package &mdash; MATRXS 0.0.1 Manual 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/matrx.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> MATRXS 0.0.1 Manual
          

          
            
            <img src="../_static/matrxslogo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">matrxs.agents package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-matrxs.agents.agent_brain">matrxs.agents.agent_brain module</a></li>
<li><a class="reference internal" href="#module-matrxs.agents.human_agent_brain">matrxs.agents.human_agent_brain module</a></li>
<li><a class="reference internal" href="#module-matrxs.agents.patrolling_agent">matrxs.agents.patrolling_agent module</a></li>
<li><a class="reference internal" href="#module-matrxs.agents">Module contents</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MATRXS 0.0.1 Manual</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>matrxs.agents package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/stub_files/matrxs.agents.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="matrxs-agents-package">
<h1>matrxs.agents package<a class="headerlink" href="#matrxs-agents-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="matrxs.agents.capabilities.html">matrxs.agents.capabilities package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matrxs.agents.capabilities.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrxs.agents.capabilities.html#module-matrxs.agents.capabilities.capability">matrxs.agents.capabilities.capability module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matrxs.agents.capabilities.html#module-matrxs.agents.capabilities">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-matrxs.agents.agent_brain">
<span id="matrxs-agents-agent-brain-module"></span><h2>matrxs.agents.agent_brain module<a class="headerlink" href="#module-matrxs.agents.agent_brain" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="matrxs.agents.agent_brain.AgentBrain">
<em class="property">class </em><code class="sig-name descname">AgentBrain</code><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.decide_on_action" title="matrxs.agents.agent_brain.AgentBrain.decide_on_action"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decide_on_action</span></code></a>(self, state)</p></td>
<td><p>Contains the decision logic of the agent.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.filter_observations" title="matrxs.agents.agent_brain.AgentBrain.filter_observations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_observations</span></code></a>(self, state)</p></td>
<td><p>Filters the state received from the world further.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.get_log_data" title="matrxs.agents.agent_brain.AgentBrain.get_log_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_log_data</span></code></a>(self)</p></td>
<td><p>Provides a dictionary of data for any Logger</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.initialize" title="matrxs.agents.agent_brain.AgentBrain.initialize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize</span></code></a>(self)</p></td>
<td><p>Method called the very first time this AgentBrain is called from the world.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.is_action_possible" title="matrxs.agents.agent_brain.AgentBrain.is_action_possible"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_action_possible</span></code></a>(self, action, action_kwargs)</p></td>
<td><p>Checks if an action would be possible.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.preprocess_messages" title="matrxs.agents.agent_brain.AgentBrain.preprocess_messages"><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocess_messages</span></code></a>(this_agent_id, …)</p></td>
<td><p>Preprocess messages for sending, such that they can be understood by the GridWorld.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain.send_message" title="matrxs.agents.agent_brain.AgentBrain.send_message"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_message</span></code></a>(self, message)</p></td>
<td><p>Sends a Message from this agent to others</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.decide_on_action">
<code class="sig-name descname">decide_on_action</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.decide_on_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the decision logic of the agent.</p>
<p>This method determines what action the agent should perform. The GridWorld is responsible for deciding when an
agent can perform an action again, if so this method is called for each agent. Two things need to be determined,
which action and with what arguments.</p>
<p>The action is returned simply as the class name (as a string), and the action arguments as a dictionary with the
keys the names of the keyword arguments. An argument that is always possible is that of action_duration, which
denotes how many ticks this action should take (e.g. a duration of 1, makes sure the agent has to wait 1 tick).</p>
<p>To quickly build a fairly intelligent agent, several utility classes and methods are available. See &lt;TODO&gt;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>A state description containing all properties of EnvObject that are within a certain range as</strong></dt><dd></dd>
<dt><strong>defined by self.sense_capability. It is a list of properties in a dictionary</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>action_name</strong><span class="classifier">str</span></dt><dd><p>A string of the class name of an action that is also in self.action_set. To ensure backwards compatibility
you could use Action.__name__ where Action is the intended action.</p>
</dd>
<dt><strong>action_args</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys any action arguments and as values the actual argument values. If a required argument
is missing an exception is raised, if an argument that is not used by that action a warning is printed. The
argument applicable to all action is <cite>action_duration</cite>, which sets the number ticks the agent is put on hold
by the GridWorld until the action’s world mutation is actual performed and the agent can perform a new
action (a value of 0 is no wait, 1 means to wait 1 tick, etc.).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.filter_observations">
<code class="sig-name descname">filter_observations</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.filter_observations" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters the state received from the world further.</p>
<p>In this method you filter the state to only those properties and objects the agent is actually supposed to see.
Since the grid world returns ALL properties of ALL objects within a certain range(s), but perhaps some objects
are obscured because they are behind walls, or an agent is not able to see some properties of certain objects.</p>
<p>This method is separated from the decide_on_action() method because its return value is send to the API as well
to allows the agent’s interface to only show that knowledge the agent is aware of.</p>
<p>A number of utility methods exist to help filter and memorize states. See &lt;TODO&gt;</p>
<p>Override this method when creating a new AgentBrain and you need to filter the state further.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state: dict</strong></dt><dd><p>A state description containing all properties of EnvObject and sub classes that are within a certain range
as defined by self.sense_capability. The object id is the key, and the value is a dictionary of properties.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_state</strong><span class="classifier">dict</span></dt><dd><p>A dictionary describing the filtered state this agent perceives of the world.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.get_log_data">
<code class="sig-name descname">get_log_data</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.get_log_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a dictionary of data for any Logger</p>
<p>This method functions to relay data from an agent’s decision logic (this AgentBrain class) through the GridWorld
into a Logger. Here it can be further processed and stored.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys identifiable names and the data as its value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called the very first time this AgentBrain is called from the world. Here you can initialize everything
you need for your agent to work since you can’t do much in the constructor as the brain needs to be connected to
a GridWorld first in most cases (e.g. to get an AgentID, its random seed, etc.)</p>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.is_action_possible">
<code class="sig-name descname">is_action_possible</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">action</em>, <em class="sig-param">action_kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.is_action_possible" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if an action would be possible.</p>
<p>This method can be called from the AgentBrain to check if a certain action is possible to perform with the
current state of the GridWorld. It requires as input an action name and its arguments (if any), same as the
decide_on_action method should return.</p>
<p>This method does not guarantees that if the action is return by the brain it actually succeeds, as other agents
may intervene.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>action</strong><span class="classifier">str</span></dt><dd><p>The name of an Action class.</p>
</dd>
<dt><strong>action_kwargs</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys any action arguments and as values the actual argument values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>succeeded</strong><span class="classifier">bool</span></dt><dd><p>True if the action can be performed, False otherwise.</p>
</dd>
<dt><strong>action_results</strong><span class="classifier">ActionResult</span></dt><dd><p>An ActionResult object containing the success or failure of the action, and (if failed) the reason why.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.preprocess_messages">
<em class="property">static </em><code class="sig-name descname">preprocess_messages</code><span class="sig-paren">(</span><em class="sig-param">this_agent_id</em>, <em class="sig-param">agent_ids</em>, <em class="sig-param">messages</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.preprocess_messages" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocess messages for sending, such that they can be understood by the GridWorld.
For example: if the receiver=None, this means it must be sent to all agents. This function creates a message
directed at every agent.</p>
<p>This is a static method such that it can also be accessed and used outside of this thread / the GridWorld loop.
Such as by the API.</p>
<p>Note; This method should NOT be overridden!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>this_agent_id</strong></dt><dd><p>ID of the current agent, has to be sent as this is a static method</p>
</dd>
<dt><strong>agent_ids</strong></dt><dd><p>IDS of all agents known</p>
</dd>
<dt><strong>messages</strong></dt><dd><p>Messages which are to be processed</p>
</dd>
<dt><strong>Returns</strong></dt><dd><p>Preprocessd messages ready for sending</p>
</dd>
<dt><strong>——-</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.agent_brain.AgentBrain.send_message">
<code class="sig-name descname">send_message</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">message</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.AgentBrain.send_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends a Message from this agent to others</p>
<p>Method that allows you to construct a message that will be send to either a specified agent, a team of agents
or all agents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>message: Message</strong></dt><dd><p>A message object that needs to be send. Should be of type Message. It’s to_id can contain a single
recipient, a list of recipients or None. If None, it is send to all other agents.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matrxs.agents.agent_brain.Message">
<em class="property">class </em><code class="sig-name descname">Message</code><span class="sig-paren">(</span><em class="sig-param">content</em>, <em class="sig-param">from_id</em>, <em class="sig-param">to_id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.agent_brain.Message" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple object representing a communication message. An agent can create such a Message object by stating the
content, its own id as the sender and (optional) a receiver. If a receiver is not given it is a message to all
agents, including the sender.
NOTE: this Message class is also used by the MATRXS API</p>
</dd></dl>

</div>
<div class="section" id="module-matrxs.agents.human_agent_brain">
<span id="matrxs-agents-human-agent-brain-module"></span><h2>matrxs.agents.human_agent_brain module<a class="headerlink" href="#module-matrxs.agents.human_agent_brain" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="matrxs.agents.human_agent_brain.HumanAgentBrain">
<em class="property">class </em><code class="sig-name descname">HumanAgentBrain</code><a class="headerlink" href="#matrxs.agents.human_agent_brain.HumanAgentBrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain" title="matrxs.agents.agent_brain.AgentBrain"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrxs.agents.agent_brain.AgentBrain</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.decide_on_action" title="matrxs.agents.human_agent_brain.HumanAgentBrain.decide_on_action"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decide_on_action</span></code></a>(self, state, usrinput)</p></td>
<td><p>Contains the decision logic of the agent.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.filter_observations" title="matrxs.agents.human_agent_brain.HumanAgentBrain.filter_observations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_observations</span></code></a>(self, state)</p></td>
<td><p>All our agent work through the OODA-loop paradigm; first you observe, then you orient/pre-process, followed by a decision process of an action after which we act upon the action.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.filter_userinput" title="matrxs.agents.human_agent_brain.HumanAgentBrain.filter_userinput"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_userinput</span></code></a>(self, userinput)</p></td>
<td><p>From the received userinput, only keep those which are actually Connected to a specific agent action</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_log_data</span></code>(self)</p></td>
<td><p>Provides a dictionary of data for any Logger</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize</span></code>(self)</p></td>
<td><p>Method called the very first time this AgentBrain is called from the world.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_action_possible</span></code>(self, action, action_kwargs)</p></td>
<td><p>Checks if an action would be possible.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocess_messages</span></code>(this_agent_id, …)</p></td>
<td><p>Preprocess messages for sending, such that they can be understood by the GridWorld.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_message</span></code>(self, message)</p></td>
<td><p>Sends a Message from this agent to others</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matrxs.agents.human_agent_brain.HumanAgentBrain.decide_on_action">
<code class="sig-name descname">decide_on_action</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em>, <em class="sig-param">usrinput</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.decide_on_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the decision logic of the agent.</p>
<p>This method determines what action the human agent will perform. The GridWorld is responsible for deciding when
an agent can perform an action again, if so this method is called for each agent. Two things need to be
determined, which action and with what arguments.</p>
<p>The action is returned simply as the class name (as a string), and the action arguments as a dictionary with the
keys the names of the keyword arguments. An argument that is always possible is that of action_duration, which
denotes how many ticks this action should take (e.g. a duration of 1, makes sure the agent has to wait 1 tick).</p>
<p>To quickly build a fairly intelligent (human) agent, several utility classes and methods are available.
See &lt;TODO&gt;.</p>
<p>Note; this function of the human_agent_brain overwrites the decide_on_action() function of the default agent,
also providing the usrinput.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">dict</span></dt><dd><p>A state description containing all properties of EnvObject that are within a certain range as
defined by self.sense_capability. It is a list of properties in a dictionary</p>
</dd>
<dt><strong>usrinput: list</strong></dt><dd><p>A dictionary containing the key presses of the user, intended for controlling thus human agent.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>action_name</strong><span class="classifier">str</span></dt><dd><p>A string of the class name of an action that is also in self.action_set. To ensure backwards compatibility
you could use Action.__name__ where Action is the intended action.</p>
</dd>
<dt><strong>action_args</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys any action arguments and as values the actual argument values. If a required argument
is missing an exception is raised, if an argument that is not used by that action a warning is printed. The
argument applicable to all action is <cite>action_duration</cite>, which sets the number ticks the agent is put on hold
by the GridWorld until the action’s world mutation is actual performed and the agent can perform a new
action (a value of 0 is no wait, 1 means to wait 1 tick, etc.).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.human_agent_brain.HumanAgentBrain.filter_observations">
<code class="sig-name descname">filter_observations</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.filter_observations" title="Permalink to this definition">¶</a></dt>
<dd><p>All our agent work through the OODA-loop paradigm; first you observe, then you orient/pre-process, followed by
a decision process of an action after which we act upon the action.</p>
<p>However, as a human agent is controlled by a human, only the observe part is executed.</p>
<p>This is the Observe phase. In this phase you filter the state further to only those properties the agent is
actually SUPPOSED to see. Since the grid world returns ALL properties of ALL objects within a certain range(s),
but perhaps some objects are obscured because they are behind walls, or an agent is not able to see some
properties an certain objects.</p>
<p>This filtering is what you do here.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>state</strong> – A state description containing all properties of EnvObject that are within a certain range as</p>
</dd>
</dl>
<p>defined by self.sense_capability. It is a list of properties in a dictionary
:return: A filtered state.</p>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.human_agent_brain.HumanAgentBrain.filter_userinput">
<code class="sig-name descname">filter_userinput</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">userinput</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.human_agent_brain.HumanAgentBrain.filter_userinput" title="Permalink to this definition">¶</a></dt>
<dd><p>From the received userinput, only keep those which are actually Connected
to a specific agent action</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-matrxs.agents.patrolling_agent">
<span id="matrxs-agents-patrolling-agent-module"></span><h2>matrxs.agents.patrolling_agent module<a class="headerlink" href="#module-matrxs.agents.patrolling_agent" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="matrxs.agents.patrolling_agent.PatrollingAgentBrain">
<em class="property">class </em><code class="sig-name descname">PatrollingAgentBrain</code><span class="sig-paren">(</span><em class="sig-param">waypoints</em>, <em class="sig-param">move_speed=1</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matrxs.agents.agent_brain.AgentBrain" title="matrxs.agents.agent_brain.AgentBrain"><code class="xref py py-class docutils literal notranslate"><span class="pre">matrxs.agents.agent_brain.AgentBrain</span></code></a></p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.decide_on_action" title="matrxs.agents.patrolling_agent.PatrollingAgentBrain.decide_on_action"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decide_on_action</span></code></a>(self, state)</p></td>
<td><p>Contains the decision logic of the agent.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.filter_observations" title="matrxs.agents.patrolling_agent.PatrollingAgentBrain.filter_observations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_observations</span></code></a>(self, state)</p></td>
<td><p>Filters the state received from the world further.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_log_data</span></code>(self)</p></td>
<td><p>Provides a dictionary of data for any Logger</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.initialize" title="matrxs.agents.patrolling_agent.PatrollingAgentBrain.initialize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize</span></code></a>(self)</p></td>
<td><p>Method called the very first time this AgentBrain is called from the world.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_action_possible</span></code>(self, action, action_kwargs)</p></td>
<td><p>Checks if an action would be possible.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">preprocess_messages</span></code>(this_agent_id, …)</p></td>
<td><p>Preprocess messages for sending, such that they can be understood by the GridWorld.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_message</span></code>(self, message)</p></td>
<td><p>Sends a Message from this agent to others</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matrxs.agents.patrolling_agent.PatrollingAgentBrain.decide_on_action">
<code class="sig-name descname">decide_on_action</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.decide_on_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the decision logic of the agent.</p>
<p>This method determines what action the agent should perform. The GridWorld is responsible for deciding when an
agent can perform an action again, if so this method is called for each agent. Two things need to be determined,
which action and with what arguments.</p>
<p>The action is returned simply as the class name (as a string), and the action arguments as a dictionary with the
keys the names of the keyword arguments. An argument that is always possible is that of action_duration, which
denotes how many ticks this action should take (e.g. a duration of 1, makes sure the agent has to wait 1 tick).</p>
<p>To quickly build a fairly intelligent agent, several utility classes and methods are available. See &lt;TODO&gt;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state</strong><span class="classifier">dict</span></dt><dd></dd>
<dt><strong>A state description containing all properties of EnvObject that are within a certain range as</strong></dt><dd></dd>
<dt><strong>defined by self.sense_capability. It is a list of properties in a dictionary</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>action_name</strong><span class="classifier">str</span></dt><dd><p>A string of the class name of an action that is also in self.action_set. To ensure backwards compatibility
you could use Action.__name__ where Action is the intended action.</p>
</dd>
<dt><strong>action_args</strong><span class="classifier">dict</span></dt><dd><p>A dictionary with keys any action arguments and as values the actual argument values. If a required argument
is missing an exception is raised, if an argument that is not used by that action a warning is printed. The
argument applicable to all action is <cite>action_duration</cite>, which sets the number ticks the agent is put on hold
by the GridWorld until the action’s world mutation is actual performed and the agent can perform a new
action (a value of 0 is no wait, 1 means to wait 1 tick, etc.).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.patrolling_agent.PatrollingAgentBrain.filter_observations">
<code class="sig-name descname">filter_observations</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.filter_observations" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters the state received from the world further.</p>
<p>In this method you filter the state to only those properties and objects the agent is actually supposed to see.
Since the grid world returns ALL properties of ALL objects within a certain range(s), but perhaps some objects
are obscured because they are behind walls, or an agent is not able to see some properties of certain objects.</p>
<p>This method is separated from the decide_on_action() method because its return value is send to the API as well
to allows the agent’s interface to only show that knowledge the agent is aware of.</p>
<p>A number of utility methods exist to help filter and memorize states. See &lt;TODO&gt;</p>
<p>Override this method when creating a new AgentBrain and you need to filter the state further.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state: dict</strong></dt><dd><p>A state description containing all properties of EnvObject and sub classes that are within a certain range
as defined by self.sense_capability. The object id is the key, and the value is a dictionary of properties.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_state</strong><span class="classifier">dict</span></dt><dd><p>A dictionary describing the filtered state this agent perceives of the world.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matrxs.agents.patrolling_agent.PatrollingAgentBrain.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#matrxs.agents.patrolling_agent.PatrollingAgentBrain.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Method called the very first time this AgentBrain is called from the world. Here you can initialize everything
you need for your agent to work since you can’t do much in the constructor as the brain needs to be connected to
a GridWorld first in most cases (e.g. to get an AgentID, its random seed, etc.)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-matrxs.agents">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-matrxs.agents" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, The MATRXS Team at TNO.nl

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #303030;
    }
    /* Sidebar */
    .wy-nav-side {
      background: #578a64;
    }
  </style>


</body>
</html>